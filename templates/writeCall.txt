/*Now each individual pseudocode has to be
	translated

	- push n arguments -> this has not to be implemented
										 -> the code itself (.vm) will have done
										 -> the push of the n arguments
	- push return-address [1]
	- push LCL						[2]
	- push ARG						[3]
	- push THIS						[4]	//
	- push THAT						[5]	//	Save THAT of the calling function
	- ARG = SP-n-5				[6]	//	Reposition ARG
	- LCL = SP						[7]	//  Reposition LCL
	- goto f							[8]	//  Transfer control
	- (return-address)		[9]	 // Declare a label for return address (check convenctions)

	SP, LCL, ARG, THIS, THAT -> These predefined symbols point, respectively, to the
														stack top and to the base addresses of the virtual
														segments local, argument, this, and that

	Hack Assembly translation:

		[1] push return-address:
			-> I need to get the class name, inside the function
				 awk -F="." (class.function)  ${print $1}\$ret.counter
			perfect we can generate the code of that, the parser will need to
			figure out that function name
				-> when the command function x.y z is read, there will be a function
					 variable that will get updated, this variable will allow me to create
					 the correct name of the return address, for each function an return counter
					 has to be updated.
			-> The idea will be the following the codeWritter will then have:
				  - std::string this->actualFunction;
				  - int this->functionReturnCounter;
			-> this->actualFunction will be updated each time the currentLine from
				 the .vm file will say " function x.y z" => this->actualFunction = "x.y"
			-> this->functionReturnCounter will be initialised to 1
				 when the currentLine from the .vm file will say " call x.y z" => this will
				 write HackAssembly code (codeWritter will write assembly) that will
				 generate a label in this form: "split(del=".",this->actualFunction)"+"$ret"+std::to_string(this->functionReturnCounter)

		[2] push LCL -> look if LCL will be in RAM[2], that convenction I need to check it

		@1
		D=M
		@0
		A=M
		M=D
		@0
		M=M+1

		[3] push ARG

		@2
		D=M
		@0
		A=M
		M=D
		@0
		M=M+1

		[4] push THIS

		@3
		D=M
		@0
		A=M
		M=D
		@0
		M=M+1

		[5] push THAT

		@4
		D=M
		@0
		A=M
		M=D
		@0
		M=M+1

		[6] ARG = SP-n-5

		@0
		D=M
		@2
		M=












*/
